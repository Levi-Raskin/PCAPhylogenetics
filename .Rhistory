setwd("/Users/levir/Documents/GitHub/PCAPhylogenetics")
set.seed(5)
rSPRFunc <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
rSPRFunc2 <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res2.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr2 -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res2.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
rSPRFunc3 <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res3.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr3 -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res3.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
rSPRFunc4 <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res4.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr4 -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res4.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
sprMast <- function(tree1, tree2){
sprDist <- rSPRFunc(tree1, tree2)
mastSize <- Ntip(phangorn::mast(tree1, tree2))
return(sprDist/mastSize)
}
sprMast2 <- function(tree1, tree2){
sprDist <- rSPRFunc2(tree1, tree2)
mastSize <- Ntip(phangorn::mast(tree1, tree2))
return(sprDist/mastSize)
}
#read tree trace
# trees <- data.table::fread("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/hominin.trees",
# nThread = 10)
#burn in
# trees <- trees[round(0.1 * nrow(trees)) : nrow(trees),]
# sample 1,000 trees from the posterior distribution
# treeSubset <- trees[sample(1:nrow(trees), 1000, replace = FALSE), ]
# rm(trees)
# write.csv(treeSubset,"/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/sampledTrees.csv")
treeSubset <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/sampledTrees.tsv")
#convert to phylo object
phyloList <- list()
for(i in 1:nrow(treeSubset)){
phyloList[[i]] <- ape::read.tree(text = as.character(treeSubset[i, 2]))
}
## PC1, 2
#rSPRFunc3
analysisFunctionProc <- function(lddmmFile){
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * numLandmarks)
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
### gpagen expects an array containing n x d slices where n is num landmarks and d is dimension of ladnmarks
pcaMat <- geomorph::arrayspecs(pcaMat, numLandmarks, k = dimension)
proc <- geomorph::gpagen(A = pcaMat, verbose = FALSE,print.progress = FALSE)
pca <- geomorph::gm.prcomp(proc$coords)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
### this is the expensive step
sprd <- rSPRFunc3(unrootedNJTree, unrootedTree)
resMat = as.data.frame(matrix(data = NA, nrow = 1, ncol = 6))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
resMat[1,] <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
resMat <- as.data.table(resMat)
fwrite(resMat, paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistancesProcrustes/", regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE)), "Procrustes", ".csv", sep = ""))
return(resMat)
}
#rSPRFunc4
analysisFunctionProc2 <- function(lddmmFile){
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * numLandmarks)
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
### gpagen expects an array containing n x d slices where n is num landmarks and d is dimension of ladnmarks
pcaMat <- geomorph::arrayspecs(pcaMat, numLandmarks, k = dimension)
proc <- geomorph::gpagen(A = pcaMat, verbose = FALSE,print.progress = FALSE)
pca <- geomorph::gm.prcomp(proc$coords)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
### this is the expensive step
sprd <- rSPRFunc4(unrootedNJTree, unrootedTree)
resMat = as.data.frame(matrix(data = NA, nrow = 1, ncol = 6))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
resMat[1,] <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
resMat <- as.data.table(resMat)
fwrite(resMat, paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistancesProcrustes/", regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE)), "Procrustes", ".csv", sep = ""))
return(resMat)
}
lddmmFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes",full.names = T)
doneFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistancesProcrustes")
#prune already analyzed lddmm files
pruneFunc <- function(lddmmFile){
tag <- regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE))
tag <- paste(tag, ".csv", sep = "")
if(tag %in% doneFiles){
}else{
return(lddmmFile)
}
}
lddmmFilesPruned <- parallel::mclapply(lddmmFiles, pruneFunc, mc.cores = 4)
lddmmFilesPruned <- unlist(lddmmFilesPruned)
rm(lddmmFiles)
rm(doneFiles)
gc()
cutoff <-round(length(lddmmFilesPruned)/2)
lddmmFilesPrunedHalf1 <- lddmmFilesPruned[1:cutoff]
lddmmFilesPrunedHalf2 <- lddmmFilesPruned[(cutoff + 1) : length(lddmmFilesPruned)]
x <- parallel::mclapply(x = 1:2, function(i){
if(i == 1){
res <- pbapply::pblapply(lddmmFilesPrunedHalf1, FUN = analysisFunctionProc)
}else{
res <- pbapply::pblapply(lddmmFilesPrunedHalf2, FUN = analysisFunctionProc2)
}
})
# Setup -------------------------------------------------------------------
library(ape)
library(dplyr)
library(ggplot2)
library(ggtree)
library(phangorn)
library(phytools)
library(tictoc)
library(data.table)
library(geomorph)
setwd("/Users/levir/Documents/GitHub/PCAPhylogenetics")
set.seed(5)
rSPRFunc <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
rSPRFunc2 <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res2.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr2 -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res2.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
rSPRFunc3 <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res3.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr3 -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res3.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
rSPRFunc4 <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res4.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr4 -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res4.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
sprMast <- function(tree1, tree2){
sprDist <- rSPRFunc(tree1, tree2)
mastSize <- Ntip(phangorn::mast(tree1, tree2))
return(sprDist/mastSize)
}
sprMast2 <- function(tree1, tree2){
sprDist <- rSPRFunc2(tree1, tree2)
mastSize <- Ntip(phangorn::mast(tree1, tree2))
return(sprDist/mastSize)
}
#read tree trace
# trees <- data.table::fread("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/hominin.trees",
# nThread = 10)
#burn in
# trees <- trees[round(0.1 * nrow(trees)) : nrow(trees),]
# sample 1,000 trees from the posterior distribution
# treeSubset <- trees[sample(1:nrow(trees), 1000, replace = FALSE), ]
# rm(trees)
# write.csv(treeSubset,"/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/sampledTrees.csv")
treeSubset <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/sampledTrees.tsv")
#convert to phylo object
phyloList <- list()
for(i in 1:nrow(treeSubset)){
phyloList[[i]] <- ape::read.tree(text = as.character(treeSubset[i, 2]))
}
analysisFunctionProc2 <- function(lddmmFile){
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * numLandmarks)
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
### gpagen expects an array containing n x d slices where n is num landmarks and d is dimension of ladnmarks
pcaMat <- geomorph::arrayspecs(pcaMat, numLandmarks, k = dimension)
proc <- geomorph::gpagen(A = pcaMat, verbose = FALSE,print.progress = FALSE)
pca <- geomorph::gm.prcomp(proc$coords)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
### this is the expensive step
sprd <- rSPRFunc4(unrootedNJTree, unrootedTree)
resMat = as.data.frame(matrix(data = NA, nrow = 1, ncol = 6))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
resMat[1,] <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
resMat <- as.data.table(resMat)
fwrite(resMat, paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistancesProcrustes/", regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE)), "Procrustes", ".csv", sep = ""))
return(resMat)
}
lddmmFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes",full.names = T)
doneFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistancesProcrustes")
#prune already analyzed lddmm files
pruneFunc <- function(lddmmFile){
tag <- regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE))
tag <- paste(tag, ".csv", sep = "")
if(tag %in% doneFiles){
}else{
return(lddmmFile)
}
}
lddmmFilesPruned <- parallel::mclapply(lddmmFiles, pruneFunc, mc.cores = 4)
## PC1, 2
#rSPRFunc3
analysisFunctionProc <- function(lddmmFile){
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * numLandmarks)
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
### gpagen expects an array containing n x d slices where n is num landmarks and d is dimension of ladnmarks
pcaMat <- geomorph::arrayspecs(pcaMat, numLandmarks, k = dimension)
proc <- geomorph::gpagen(A = pcaMat, verbose = FALSE,print.progress = FALSE)
pca <- geomorph::gm.prcomp(proc$coords)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
### this is the expensive step
sprd <- rSPRFunc3(unrootedNJTree, unrootedTree)
resMat = as.data.frame(matrix(data = NA, nrow = 1, ncol = 6))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
resMat[1,] <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
resMat <- as.data.table(resMat)
fwrite(resMat, paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistancesProcrustes/", regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE)), "Procrustes", ".csv", sep = ""))
return(resMat)
}
#rSPRFunc4
analysisFunctionProc2 <- function(lddmmFile){
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * numLandmarks)
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
### gpagen expects an array containing n x d slices where n is num landmarks and d is dimension of ladnmarks
pcaMat <- geomorph::arrayspecs(pcaMat, numLandmarks, k = dimension)
proc <- geomorph::gpagen(A = pcaMat, verbose = FALSE,print.progress = FALSE)
pca <- geomorph::gm.prcomp(proc$coords)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
### this is the expensive step
sprd <- rSPRFunc4(unrootedNJTree, unrootedTree)
resMat = as.data.frame(matrix(data = NA, nrow = 1, ncol = 6))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
resMat[1,] <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
resMat <- as.data.table(resMat)
fwrite(resMat, paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistancesProcrustes/", regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE)), "Procrustes", ".csv", sep = ""))
return(resMat)
}
lddmmFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes",full.names = T)
doneFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistancesProcrustes")
#prune already analyzed lddmm files
pruneFunc <- function(lddmmFile){
tag <- regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE))
tag <- paste(tag, "Procrustes.csv", sep = "")
if(tag %in% doneFiles){
}else{
return(lddmmFile)
}
}
lddmmFilesPruned <- parallel::mclapply(lddmmFiles, pruneFunc, mc.cores = 8)
#lddmmFilesPruned <- unlist(lddmmFilesPruned)
rm(lddmmFiles)
rm(doneFiles)
gc()
data.table::fwrite(lddmmFilesPruned, "/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/PC1PC2.tsv",col.names = FALSE)
length(lddmmFilesPruned)
View(lddmmFilesPruned)
lddmmFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes",full.names = T)
doneFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistancesProcrustes")
lddmmFile = lddmmFiles[1]
tag <- regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE))
tah
tag
tag <- paste(tag, "Procrustes.csv", sep = "")
tah
tag
doneFiles[1]
tag %in% doneFiles
#prune already analyzed lddmm files
pruneFunc <- function(lddmmFile){
tag <- regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE))
tag <- paste(tag, "Procrustes.csv", sep = "")
if(tag %in% doneFiles){
}else{
return(lddmmFile)
}
}
tag <- regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE))
tag <- paste(tag, "Procrustes.csv", sep = "")
tag
tag %in% doneFiles
lddmmFilesPruned <- parallel::mclapply(lddmmFiles, pruneFunc, mc.cores = 8)
#rSPRFunc2
analysisFunctionProcAll <- function(lddmmFile){
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * numLandmarks)
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
### gpagen expects an array containing n x d slices where n is num landmarks and d is dimension of ladnmarks
pcaMat <- geomorph::arrayspecs(pcaMat, numLandmarks, k = dimension)
proc <- geomorph::gpagen(A = pcaMat, verbose = FALSE,print.progress = FALSE)
pca <- geomorph::gm.prcomp(proc$coords)
pcDistMat<- dist(pca$x)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
### this is the expensive step
sprd <- rSPRFunc2(unrootedNJTree, unrootedTree)
resMat = as.data.frame(matrix(data = NA, nrow = 1, ncol = 6))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
resMat[1,] <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
resMat <- as.data.table(resMat)
fwrite(resMat, paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistancesProcrustesAllPCs/", regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE)), "Procrustes", ".csv", sep = ""))
return(resMat)
}
lddmmFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes",full.names = T)
doneFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistancesProcrustesAllPCs")
#prune already analyzed lddmm files
pruneFunc <- function(lddmmFile){
tag <- regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE))
tag <- paste(tag, "Procrustes.csv", sep = "")
if(tag %in% doneFiles){
}else{
return(lddmmFile)
}
}
lddmmFilesPruned <- parallel::mclapply(lddmmFiles, pruneFunc, mc.cores = 4)
lddmmFilesPruned <- unlist(lddmmFilesPruned)
rm(lddmmFiles)
rm(doneFiles)
gc()
res <- pbapply::pblapply(lddmmFilesPruned, FUN = analysisFunctionProcAll)
