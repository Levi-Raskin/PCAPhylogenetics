# Setup -------------------------------------------------------------------
library(ape)
library(dplyr)
library(ggplot2)
library(ggtree)
library(phangorn)
library(phytools)
setwd("/Users/levir/Documents/GitHub/PCAPhylogenetics")
set.seed(5)
rSPRFunc <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
sprMast <- function(tree1, tree2){
sprDist <- rSPRFunc(tree1, tree2)
mastSize <- Ntip(phangorn::mast(tree1, tree2))
return(sprDist/mastSize)
}
#read tree trace
# trees <- data.table::fread("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/hominin.trees",
# nThread = 10)
#burn in
# trees <- trees[round(0.1 * nrow(trees)) : nrow(trees),]
# sample 1,000 trees from the posterior distribution
# treeSubset <- trees[sample(1:nrow(trees), 1000, replace = FALSE), ]
# rm(trees)
# write.csv(treeSubset,"/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/sampledTrees.csv")
treeSubset <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/sampledTrees.tsv")
#convert to phylo object
phyloList <- list()
for(i in 1:nrow(treeSubset)){
phyloList[[i]] <- ape::read.tree(text = as.character(treeSubset[i, 2]))
}
# LDDMM results -----------------------------------------------------------
library(tictoc)
library(data.table)
library(tictoc)
library(data.table)
analysisFunction <- function(lddmmFile){
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * 10) #currently onyl 10 lms
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
pca <- prcomp(pcaMat)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
### this is the expensive step
sprd <- rSPRFunc(unrootedNJTree, unrootedTree)
resMat = as.data.frame(matrix(data = NA, nrow = 1, ncol = 6))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
resMat[1,] <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
resMat <- as.data.table(resMat)
fwrite(resMat, paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistances/", regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE)), ".csv", sep = ""))
return(resMat)
}
lddmmFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes",full.names = T)
doneFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistances")
#prune already analyzed lddmm files
pruneFunc <- function(lddmmFile){
tag <- regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE))
tag <- paste(tag, ".csv", sep = "")
if(tag %in% doneFiles){
}else{
return(lddmmFile)
}
}
lddmmFilesPruned <- parallel::mclapply(lddmmFiles, pruneFunc, mc.cores = 4)
lddmmFilesPruned <- unlist(lddmmFilesPruned)
res <- pbapply::pblapply(lddmmFilesPruned, FUN = analysisFunction)
lddmmFile = lddmmFilesPruned[1]
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * 10) #currently onyl 10 lms
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
pcaMat
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
landmarks
View(landmarks)
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * 10) #currently onyl 10 lms
pcaMat
rownames(pcaMat) = unique(landmarks$label)
pcaMat
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * numLandmarks)
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
pca <- prcomp(pcaMat)
pcaMat
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
### this is the expensive step
sprd <- rSPRFunc(unrootedNJTree, unrootedTree)
resMat = as.data.frame(matrix(data = NA, nrow = 1, ncol = 6))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
resMat[1,] <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
resMat <- as.data.table(resMat)
resMat
analysisFunction <- function(lddmmFile){
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * numLandmarks)
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
pca <- prcomp(pcaMat)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
### this is the expensive step
sprd <- rSPRFunc(unrootedNJTree, unrootedTree)
resMat = as.data.frame(matrix(data = NA, nrow = 1, ncol = 6))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
resMat[1,] <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
resMat <- as.data.table(resMat)
fwrite(resMat, paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMDistances/", regmatches(lddmmFile, regexpr("(?<=SimRes/LDDMMSimRes/).*?(?=.tsv)", lddmmFile, perl = TRUE)), ".csv", sep = ""))
return(resMat)
}
res <- pbapply::pblapply(lddmmFilesPruned, FUN = analysisFunction)
