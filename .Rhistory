arrange(-y) %>%
pull(label)
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha03.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.400000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha04.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
simResPC1PC2 <- readRDS("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/simulationResults.rds")
### 3D
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.100000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
# Make individual plots with custom y range
compute_global_xrange <- function(data, taxa) {
all_proj_x <- c()
for (tip in taxa) {
dat <- dplyr::filter(data, taxon == tip)
dat$x <- dat$x - mean(dat$x)
dat$y <- dat$y - mean(dat$y)
dat$z <- dat$z - mean(dat$z)
x2d <- dat$x - dat$y * 0.5  # same as in your project_points()
all_proj_x <- c(all_proj_x, x2d)
}
return(range(all_proj_x))
}
stackFunc <- function(tip) {
dat <- filter(lddmmRes1Alpha0.2, taxon == tip)
#center dat
dat$x <- dat$x - mean(dat$x)
dat$y <- dat$y - mean(dat$y)
dat$z <- dat$z - mean(dat$z)
norms <- sqrt(rowSums(dat^2))
# Divide each row by its norm
dat <- dat / norms
y_pad <- 1.0  # Add vertical padding
y_min <- min(dat$y) - y_pad
y_max <- max(dat$y) + y_pad
x_pad <- 1.0  # Add vertical padding
x_min <- min(dat$x) - x_pad
x_max <- max(dat$x) + x_pad
df <- dat[,3:5]
hull_faces <- geometry::convhulln(df, output.options = TRUE)$hull
get_edges <- function(faces) {
edges <- do.call(rbind, lapply(1:nrow(faces), function(i) {
tri <- faces[i, ]
rbind(tri[c(1, 2)], tri[c(2, 3)], tri[c(3, 1)])
}))
edges <- unique(t(apply(edges, 1, sort)))
return(edges)
}
edges <- get_edges(hull_faces)
hull_vertices <- unique(as.vector(hull_faces))
project_points <- function(x, y, z) {
x2d <- x - y * 0.5
y2d <- z - y * 0.5
return(data.frame(x2d = x2d, y2d = y2d))
}
projected_df <- project_points(df$x, df$y, df$z)
edge_df <- do.call(rbind, lapply(1:nrow(edges), function(i) {
idx1 <- edges[i, 1]
idx2 <- edges[i, 2]
p1 <- df[idx1, ]
p2 <- df[idx2, ]
proj1 <- projected_df[idx1, ]
proj2 <- projected_df[idx2, ]
mean_z <- mean(c(p1$z, p2$z))
data.frame(
x = proj1$x2d, y = proj1$y2d,
xend = proj2$x2d, yend = proj2$y2d,
depth = mean_z
)
}))
depth_range <- range(edge_df$depth)
edge_df$gray <- (edge_df$depth - depth_range[1]) / diff(depth_range)
edge_df$color <- gray(1 - edge_df$gray)
hull_points <- df[hull_vertices, ]
projected_points <- project_points(hull_points$x, hull_points$y, hull_points$z)
projected_points$z <- hull_points$z
projected_points$gray <- (projected_points$z - min(df$z)) / diff(range(df$z))
projected_points$color <- gray(1 - projected_points$gray)
projected_points <- projected_points %>%
arrange(z)
ggplot() +
geom_segment(data = edge_df,
aes(x = x,
y = y,
xend = xend,
yend = yend,
color = depth,
alpha = depth),
linewidth = 1) +
scale_alpha_continuous(range = c(0.4, 0.6))+
geom_point(data = projected_points,
aes(x = x2d,
y = y2d,
color = z,
size = z)) +
scale_color_gradient(low = "grey", high = "black") +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(y_min, y_max)) +
theme_minimal() +
ggtitle(tip) +
theme(
plot.title = element_text(hjust = 0, size = 9),
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank(),
legend.position="none",
plot.margin = margin(2, 2, 2, 2)
)
}
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha01.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
### 3D
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.100000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
tip
tip = taxap1
tip = taxa[1]
tip
dat <- filter(lddmmRes1Alpha0.2, taxon == tip)
dat
#center dat
dat$x <- dat$x - mean(dat$x)
dat$y <- dat$y - mean(dat$y)
dat$z <- dat$z - mean(dat$z)
norms <- sqrt(rowSums(dat^2))
?rowSums
rowSums(dat^2)
rowSums(dat
)
rowSums(dat)
dat
class(dat)
norms <- sqrt(rowSums(dat[,3:5]^2))
### 3D
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.100000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
# Make individual plots with custom y range
compute_global_xrange <- function(data, taxa) {
all_proj_x <- c()
for (tip in taxa) {
dat <- dplyr::filter(data, taxon == tip)
dat$x <- dat$x - mean(dat$x)
dat$y <- dat$y - mean(dat$y)
dat$z <- dat$z - mean(dat$z)
x2d <- dat$x - dat$y * 0.5  # same as in your project_points()
all_proj_x <- c(all_proj_x, x2d)
}
return(range(all_proj_x))
}
stackFunc <- function(tip) {
dat <- filter(lddmmRes1Alpha0.2, taxon == tip)
#center dat
dat$x <- dat$x - mean(dat$x)
dat$y <- dat$y - mean(dat$y)
dat$z <- dat$z - mean(dat$z)
norms <- sqrt(rowSums(dat[,3:5]^2))
# Divide each row by its norm
dat[,3:5] <- dat[,3:5] / norms
y_pad <- 1.0  # Add vertical padding
y_min <- min(dat$y) - y_pad
y_max <- max(dat$y) + y_pad
x_pad <- 1.0  # Add vertical padding
x_min <- min(dat$x) - x_pad
x_max <- max(dat$x) + x_pad
df <- dat[,3:5]
hull_faces <- geometry::convhulln(df, output.options = TRUE)$hull
get_edges <- function(faces) {
edges <- do.call(rbind, lapply(1:nrow(faces), function(i) {
tri <- faces[i, ]
rbind(tri[c(1, 2)], tri[c(2, 3)], tri[c(3, 1)])
}))
edges <- unique(t(apply(edges, 1, sort)))
return(edges)
}
edges <- get_edges(hull_faces)
hull_vertices <- unique(as.vector(hull_faces))
project_points <- function(x, y, z) {
x2d <- x - y * 0.5
y2d <- z - y * 0.5
return(data.frame(x2d = x2d, y2d = y2d))
}
projected_df <- project_points(df$x, df$y, df$z)
edge_df <- do.call(rbind, lapply(1:nrow(edges), function(i) {
idx1 <- edges[i, 1]
idx2 <- edges[i, 2]
p1 <- df[idx1, ]
p2 <- df[idx2, ]
proj1 <- projected_df[idx1, ]
proj2 <- projected_df[idx2, ]
mean_z <- mean(c(p1$z, p2$z))
data.frame(
x = proj1$x2d, y = proj1$y2d,
xend = proj2$x2d, yend = proj2$y2d,
depth = mean_z
)
}))
depth_range <- range(edge_df$depth)
edge_df$gray <- (edge_df$depth - depth_range[1]) / diff(depth_range)
edge_df$color <- gray(1 - edge_df$gray)
hull_points <- df[hull_vertices, ]
projected_points <- project_points(hull_points$x, hull_points$y, hull_points$z)
projected_points$z <- hull_points$z
projected_points$gray <- (projected_points$z - min(df$z)) / diff(range(df$z))
projected_points$color <- gray(1 - projected_points$gray)
projected_points <- projected_points %>%
arrange(z)
ggplot() +
geom_segment(data = edge_df,
aes(x = x,
y = y,
xend = xend,
yend = yend,
color = depth,
alpha = depth),
linewidth = 1) +
scale_alpha_continuous(range = c(0.4, 0.6))+
geom_point(data = projected_points,
aes(x = x2d,
y = y2d,
color = z,
size = z)) +
scale_color_gradient(low = "grey", high = "black") +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(y_min, y_max)) +
theme_minimal() +
ggtitle(tip) +
theme(
plot.title = element_text(hjust = 0, size = 9),
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank(),
legend.position="none",
plot.margin = margin(2, 2, 2, 2)
)
}
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha01.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.200000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha02.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.300000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha03.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.400000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha04.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
simResPC1PC2 <- readRDS("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/simulationResults.rds")
simRes2550PC1PC2 <- readRDS("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/simulationResults25char50char.rds")
simRes500PC1PC2 <- readRDS("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/simulationResults500char.rds")
library(dplyr)
library(ggplot2)
library(ggtree)
library(phangorn)
library(phytools)
library(tictoc)
library(data.table)
library(geomorph)
setwd("/Users/levir/Documents/GitHub/PCAPhylogenetics")
set.seed(5)
rSPRFunc <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
rSPRFunc2 <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res2.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr2 -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res2.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
rSPRFunc3 <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res3.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr3 -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res3.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
rSPRFunc4 <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res4.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr4 -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res4.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
distMat <- matrix(data = NA, nrow = n, ncol = 2)
n <- 10000
distMat <- matrix(data = NA, nrow = n, ncol = 2)
colnames(distMat) = c("RF", "SPR")
for(i in 1:n){
t0 <- ape::rtree(21, rooted = FALSE)
t1 <- ape::rtree(21, rooted = FALSE)
distMat[i, 1] <- dist.topo(t0, t1)
distMat[i, 2] <- rSPRFunc(t0, t1)
if(i %% 100 == 0){
print(paste("On gen", i))
}
}
library(doParallel)
library(foreach)
n <- 10000
numCores <- 4
cl <- makeCluster(numCores)
registerDoParallel(cl)
distMat <- foreach(i = 1:n, .combine = rbind, .packages = "ape") %dopar% {
t0 <- ape::rtree(21, rooted = FALSE)
t1 <- ape::rtree(21, rooted = FALSE)
rf <- dist.topo(t0, t1)
spr <- switch((i %% 4) + 1,
rSPRFunc(t0, t1),
rSPRFunc2(t0, t1),
rSPRFunc3(t0, t1),
rSPRFunc4(t0, t1)
)
c(rf, spr)
}
stopCluster(cl)
library(doParallel)
library(foreach)
n <- 10000
numCores <- 4
cl <- makeCluster(numCores)
registerDoParallel(cl)
distMat <- foreach(i = 1:n, .combine = rbind, .packages = "ape") %dopar% {
t0 <- ape::rtree(21, rooted = FALSE)
t1 <- ape::rtree(21, rooted = FALSE)
rf <- dist.topo(t0, t1)
spr <- switch((i %% 4) + 1,
rSPRFunc(t0, t1),
rSPRFunc2(t0, t1),
rSPRFunc3(t0, t1),
rSPRFunc4(t0, t1)
)
c(rf, spr)
}
stopCluster(cl)
colnames(distMat) <- c("RF", "SPR")
write.csv(distMat, file = "results/Mongle_et_al_2023_RB/nullDistribution.csv")
summary(distMat[,1])
summary(distMat[,2])
distMat <- read.csv("results/Mongle_et_al_2023_RB/nullDistribution.csv")
rfPVal <- function(val){
p <-sum(abs(distMat[,1] - median(distMat[,1])) >= abs(val - median(distMat[,1]))) / length(distMat[,1])
return(p)
}
sprPVal <- function(val){
p <-sum(abs(distMat[,2] - median(distMat[,2])) >= abs(val - median(distMat[,2]))) / length(distMat[,2])
return(p)
}
sprPVal(10)
summary(distMat[,2])
sprPVal <- function(val){
p <-sum(abs(distMat[,1] - median(distMat[,1])) >= abs(val - median(distMat[,1]))) / length(distMat[,1])
return(p)
}
rfPVal <- function(val){
p <-sum(abs(distMat[,2] - median(distMat[,2])) >= abs(val - median(distMat[,2]))) / length(distMat[,2])
return(p)
}
sprPVal(10)
distMat
head(distMat)
distMat <- read.csv("results/Mongle_et_al_2023_RB/nullDistribution.csv", row.names =FALSE)
distMat
head(distMat)
nrow(distMat)
distMat <- read.csv("results/Mongle_et_al_2023_RB/nullDistribution.csv")[,2:#]
sdaf
)
distMat <- read.csv("results/Mongle_et_al_2023_RB/nullDistribution.csv")[,2:3]
distMat
rfPVal <- function(val){
p <-sum(abs(distMat[,1] - median(distMat[,1])) >= abs(val - median(distMat[,1]))) / length(distMat[,1])
return(p)
}
sprPVal <- function(val){
p <-sum(abs(distMat[,2] - median(distMat[,2])) >= abs(val - median(distMat[,2]))) / length(distMat[,2])
return(p)
}
sprPVal(10)
sprPVal(2)
rfPVal(32)
sprPVal(9)
sprPVal(11)
rfPVal(36)
rfPVal(34)
sprPVal(5)
min(distMat[,2])
summary(distMat)
ape::howmanytrees(21)
20000 / 3.19831e+23
(20000 / 3.19831e+23)*100
