color = z,
size = z)) +
scale_color_gradient(low = "grey", high = "black") +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(y_min, y_max)) +
theme_minimal() +
ggtitle(tip) +
theme(
plot.title = element_text(hjust = 0, size = 9),
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank(),
legend.position="none",
plot.margin = margin(2, 2, 2, 2)
)
}
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha01.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
### 3D
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.100000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
tip
tip = taxap1
tip = taxa[1]
tip
dat <- filter(lddmmRes1Alpha0.2, taxon == tip)
dat
#center dat
dat$x <- dat$x - mean(dat$x)
dat$y <- dat$y - mean(dat$y)
dat$z <- dat$z - mean(dat$z)
norms <- sqrt(rowSums(dat^2))
?rowSums
rowSums(dat^2)
rowSums(dat
)
rowSums(dat)
dat
class(dat)
norms <- sqrt(rowSums(dat[,3:5]^2))
### 3D
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.100000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
# Make individual plots with custom y range
compute_global_xrange <- function(data, taxa) {
all_proj_x <- c()
for (tip in taxa) {
dat <- dplyr::filter(data, taxon == tip)
dat$x <- dat$x - mean(dat$x)
dat$y <- dat$y - mean(dat$y)
dat$z <- dat$z - mean(dat$z)
x2d <- dat$x - dat$y * 0.5  # same as in your project_points()
all_proj_x <- c(all_proj_x, x2d)
}
return(range(all_proj_x))
}
stackFunc <- function(tip) {
dat <- filter(lddmmRes1Alpha0.2, taxon == tip)
#center dat
dat$x <- dat$x - mean(dat$x)
dat$y <- dat$y - mean(dat$y)
dat$z <- dat$z - mean(dat$z)
norms <- sqrt(rowSums(dat[,3:5]^2))
# Divide each row by its norm
dat[,3:5] <- dat[,3:5] / norms
y_pad <- 1.0  # Add vertical padding
y_min <- min(dat$y) - y_pad
y_max <- max(dat$y) + y_pad
x_pad <- 1.0  # Add vertical padding
x_min <- min(dat$x) - x_pad
x_max <- max(dat$x) + x_pad
df <- dat[,3:5]
hull_faces <- geometry::convhulln(df, output.options = TRUE)$hull
get_edges <- function(faces) {
edges <- do.call(rbind, lapply(1:nrow(faces), function(i) {
tri <- faces[i, ]
rbind(tri[c(1, 2)], tri[c(2, 3)], tri[c(3, 1)])
}))
edges <- unique(t(apply(edges, 1, sort)))
return(edges)
}
edges <- get_edges(hull_faces)
hull_vertices <- unique(as.vector(hull_faces))
project_points <- function(x, y, z) {
x2d <- x - y * 0.5
y2d <- z - y * 0.5
return(data.frame(x2d = x2d, y2d = y2d))
}
projected_df <- project_points(df$x, df$y, df$z)
edge_df <- do.call(rbind, lapply(1:nrow(edges), function(i) {
idx1 <- edges[i, 1]
idx2 <- edges[i, 2]
p1 <- df[idx1, ]
p2 <- df[idx2, ]
proj1 <- projected_df[idx1, ]
proj2 <- projected_df[idx2, ]
mean_z <- mean(c(p1$z, p2$z))
data.frame(
x = proj1$x2d, y = proj1$y2d,
xend = proj2$x2d, yend = proj2$y2d,
depth = mean_z
)
}))
depth_range <- range(edge_df$depth)
edge_df$gray <- (edge_df$depth - depth_range[1]) / diff(depth_range)
edge_df$color <- gray(1 - edge_df$gray)
hull_points <- df[hull_vertices, ]
projected_points <- project_points(hull_points$x, hull_points$y, hull_points$z)
projected_points$z <- hull_points$z
projected_points$gray <- (projected_points$z - min(df$z)) / diff(range(df$z))
projected_points$color <- gray(1 - projected_points$gray)
projected_points <- projected_points %>%
arrange(z)
ggplot() +
geom_segment(data = edge_df,
aes(x = x,
y = y,
xend = xend,
yend = yend,
color = depth,
alpha = depth),
linewidth = 1) +
scale_alpha_continuous(range = c(0.4, 0.6))+
geom_point(data = projected_points,
aes(x = x2d,
y = y2d,
color = z,
size = z)) +
scale_color_gradient(low = "grey", high = "black") +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(y_min, y_max)) +
theme_minimal() +
ggtitle(tip) +
theme(
plot.title = element_text(hjust = 0, size = 9),
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank(),
legend.position="none",
plot.margin = margin(2, 2, 2, 2)
)
}
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha01.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.200000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha02.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.300000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha03.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
lddmmRes1Alpha0.2 <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/threeDimensionSimTreeIndex0LM10Alpha0.400000Dataset1nodeShapes.tsv", header = FALSE)
colnames(lddmmRes1Alpha0.2) <- c("taxon", "id", "x", "y", "z")
lddmmRes1Alpha0.2$taxon <- gsub("_", lddmmRes1Alpha0.2$taxon, replacement = " ")
tip_order <- p1$data %>%
filter(isTip) %>%
arrange(-y) %>%
pull(label)
taxa <- unique(lddmmRes1Alpha0.2$taxon)
x_range <- compute_global_xrange(lddmmRes1Alpha0.2, taxa)
plots <- lapply(tip_order, stackFunc)
# Stack vertically
stack_plot <-patchwork::wrap_plots(plots, ncol = 1)
stack_plot
ggsave(filename = paste(output, "3Dfig1LDDMMAlpha04.svg", sep = ""),
plot = stack_plot,
width = 2,
height = 42)
simResPC1PC2 <- readRDS("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/simulationResults.rds")
simRes2550PC1PC2 <- readRDS("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/simulationResults25char50char.rds")
simRes500PC1PC2 <- readRDS("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/simulationResults500char.rds")
analysisFunction <- function(lddmmFile){
resMat <- data.frame(matrix(data = NA, nrow = 0, ncol = 8))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=Index).*?(?=Alpha)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=SimRes//).*?(?=Dimension)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * 10) #currently onyl 10 lms
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
pca <- prcomp(pcaMat)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
return(rSPRFunc(unrootedNJTree, unrootedTree))
}
lddmmFiles <- list.files("results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/",full.names = T)
lddmmFiles
lddmmFiles <- list.files("Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes/",full.names = T)
lddmmFiles
# Setup -------------------------------------------------------------------
library(ape)
library(dplyr)
library(ggplot2)
library(ggtree)
library(phangorn)
library(phytools)
setwd("/Users/levir/Documents/GitHub/PCAPhylogenetics")
set.seed(5)
rSPRFunc <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
sprMast <- function(tree1, tree2){
sprDist <- rSPRFunc(tree1, tree2)
mastSize <- Ntip(phangorn::mast(tree1, tree2))
return(sprDist/mastSize)
}
#read tree trace
# trees <- data.table::fread("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/hominin.trees",
# nThread = 10)
#burn in
# trees <- trees[round(0.1 * nrow(trees)) : nrow(trees),]
# sample 1,000 trees from the posterior distribution
# treeSubset <- trees[sample(1:nrow(trees), 1000, replace = FALSE), ]
# rm(trees)
# write.csv(treeSubset,"/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/sampledTrees.csv")
treeSubset <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/sampledTrees.tsv")
#convert to phylo object
phyloList <- list()
for(i in 1:nrow(treeSubset)){
phyloList[[i]] <- ape::read.tree(text = as.character(treeSubset[i, 2]))
}
analysisFunction <- function(lddmmFile){
resMat <- data.frame(matrix(data = NA, nrow = 0, ncol = 8))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=Index).*?(?=Alpha)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=SimRes//).*?(?=Dimension)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * 10) #currently onyl 10 lms
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
pca <- prcomp(pcaMat)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
return(rSPRFunc(unrootedNJTree, unrootedTree))
}
res <- parallel::mclapply(lddmmFiles, FUN = analysisFunction, mc.cores = 12)
res <- pbapply::pblapply(lddmmFiles, FUN = analysisFunction)
getwd
getwd()
lddmmFiles <- list.files("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/LDDMMSimRes",full.names = T)
res <- pbapply::pblapply(lddmmFiles, FUN = analysisFunction)
lddmmFile = lddmmFiles[1]
resMat <- data.frame(matrix(data = NA, nrow = 0, ncol = 8))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=Index).*?(?=Alpha)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=SimRes//).*?(?=Dimension)", lddmmFile, perl = TRUE)))
dimension
lddmmFile
dimension <- (regmatches(lddmmFile, regexpr("(?<=SimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
dimension
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
dimension
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * 10) #currently onyl 10 lms
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
pca <- prcomp(pcaMat)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
njTree
phyloList
regmatches(lddmmFile, regexpr("(?<=Index).*?(?=Alpha)", lddmmFile, perl = TRUE))
lddmmFile
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
tree
as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * 10) #currently onyl 10 lms
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
pca <- prcomp(pcaMat)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
rSPRFunc(unrootedNJTree, unrootedTree)
resMat <- data.frame(matrix(data = NA, nrow = 0, ncol = 8))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
lddmmFile
regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
sprd <- rSPRFunc(unrootedNJTree, unrootedTree)
resMat[1, ] <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
resMat <- data.frame(matrix(data = NA, nrow = 0, ncol = 6))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
sprd <- rSPRFunc(unrootedNJTree, unrootedTree)
resMat[1, ] <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
resMat
resMat <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
names(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
resMat
analysisFunction <- function(lddmmFile){
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * 10) #currently onyl 10 lms
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
pca <- prcomp(pcaMat)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resMat <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
names(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
return(resMat)
}
res <- pbapply::pblapply(lddmmFiles, FUN = analysisFunction)
res
x <- unlist(res)
resmat <- matrix(data = NA, nrow = 0, ncol = 6)
resmat <- matrix(data = NA, nrow = 0, ncol = 6)
for(i in 1:length(res)){
resmat[i, ] <- res[[i]]
}
res[[i]]
resmat <- matrix(data = NA, nrow = 0, ncol = 6)
resmat <- matrix(data = NA, nrow = length(res), ncol = 6)
for(i in 1:length(res)){
resmat[i, ] <- res[[i]]
}
resmat
summary(resmat[,2])
rSPRFunc()
rSPRFunc
analysisFunction <- function(lddmmFile){
tree <- phyloList[[1+as.numeric(regmatches(lddmmFile, regexpr("(?<=DimensionSimTreeIndex).*?(?=LM)", lddmmFile, perl = TRUE)))]]
dimension <- (regmatches(lddmmFile, regexpr("(?<=LDDMMSimRes/).*?(?=Dimension)", lddmmFile, perl = TRUE)))
numLandmarks <- as.numeric(regmatches(lddmmFile, regexpr("(?<=LM).*?(?=Alpha)", lddmmFile, perl = TRUE)))
alpha <- as.numeric(regmatches(lddmmFile, regexpr("(?<=Alpha).*?(?=Dataset)", lddmmFile, perl = TRUE)))
if(dimension == "three"){
dimension <- 3
}else if(dimension == "two"){
dimension <- 2
}
landmarks <- read.delim(lddmmFile, header = F)
cn <- colnames(landmarks)
cn[1] <- "label"
cn[2] <- "lm"
colnames(landmarks) <- cn
pcaMat <- matrix(data = NA, nrow = length(unique(landmarks$label)), ncol = dimension * 10) #currently onyl 10 lms
rownames(pcaMat) = unique(landmarks$label)
for(i in unique(landmarks$label)){
lm <- as.matrix(filter(landmarks, label == i))
lm <- c(lm[, 3:ncol(lm)])
for(j in 1:length(lm)){
pcaMat[which(rownames(pcaMat)== i), j] = as.numeric(lm[j])
}
}
pca <- prcomp(pcaMat)
pcDistMat<- dist(pca$x[,1:2])
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
sprd <- rSPRFunc(unrootedNJTree, unrootedTree)
resMat <- c(dist.topo(unrootedNJTree, unrootedTree), sprd, sprd / Ntip(mast(unrootedNJTree, unrootedTree)),numLandmarks, dimension, alpha)
names(resMat) <- c("RF", "SPR", "SPRe", "numLandmarks", "Dimension", "alpha")
return(resMat)
}
summary(resmat[,1])
