library(dplyr)
library(gghalves)
library(ggnewscale)
library(ggplot2)
library(ggtree)
library(plotly)
library(RColorBrewer)
output <- "/Users/levir/Documents/GitHub/PCAPhylogenetics/manuscript/figures/"
treeSubset <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/sampledTrees.tsv")
#convert to phylo object
phyloList <- list()
for(i in 1:nrow(treeSubset)){
phyloList[[i]] <- ape::read.tree(text = as.character(treeSubset[i, 2]))
}
tree <- phyloList[[1]]
tree$tip.label <- gsub("_", tree$tip.label, replacement = " ")
p1 <- ggtree(tree)+
geom_tiplab(fontface = 4)+
xlim(NA, 5)
p1 <- ggtree::rotate(p1, 36)
p1
continuousData <- read.csv("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree1NumChar50SetRate0.1PropConflicting0Dataset100.csv")
View(continuousData)
# Setup -------------------------------------------------------------------
library(ape)
library(dplyr)
library(ggplot2)
library(ggtree)
library(phangorn)
library(phytools)
setwd("/Users/levir/Documents/GitHub/PCAPhylogenetics")
set.seed(5)
rSPRFunc <- function(tree1, tree2){
treelist <- list(tree1, tree2)
write.tree(treelist, paste(getwd(), "/rSPR/res.nwk", sep = ""))
res <- system(
paste(getwd(),
"/rSPR/rspr -pairwise -unrooted -no-symmetric-pairwise < ",
getwd(),
"/rSPR/res.nwk", sep = "")
, intern = T)
nums <- sub("^[^,]*,\\s*([0-9]+)\"?$", "\\1", res[[1]])
return(as.integer(nums))
}
sprMast <- function(tree1, tree2){
sprDist <- rSPRFunc(tree1, tree2)
mastSize <- Ntip(phangorn::mast(tree1, tree2))
return(sprDist/mastSize)
}
#read tree trace
# trees <- data.table::fread("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/hominin.trees",
# nThread = 10)
#burn in
# trees <- trees[round(0.1 * nrow(trees)) : nrow(trees),]
# sample 1,000 trees from the posterior distribution
# treeSubset <- trees[sample(1:nrow(trees), 1000, replace = FALSE), ]
# rm(trees)
# write.csv(treeSubset,"/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/sampledTrees.csv")
treeSubset <- read.delim("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/sampledTrees.tsv")
#convert to phylo object
phyloList <- list()
for(i in 1:nrow(treeSubset)){
phyloList[[i]] <- ape::read.tree(text = as.character(treeSubset[i, 2]))
}
# Parameters --------------------------------------------------------------
numDatasets <- 1:99
numCharacters <- c(10, 100, 250)
setRate <- c(0.1, 1, 10)
proportionConflicting <- c(0, 0.1, 0.25, 0.5) #proportion of characters that exhibit conflicting phylogenetic signal
# proportionConflicting <- c(0)
numTaxaConflicting <- c(2) #just rearranging 2 taxa to start
#variableRates # drawn from gamma with parameters (1,10); (1,1); (10,1)
# Simulation --------------------------------------------------------------
simulationFunction <- function(tree, treeIdx){
resMat <- data.frame(matrix(data = NA, nrow = 0, ncol = 8))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numCharacters", "setRate", "variableRateShape", "variableRateScale", "propConflicting")
for(nC in numCharacters){
for(sR in setRate){
for(pc in proportionConflicting){
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
traits <- fastBM(tree, sig2 = sR)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD), paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "SetRate", sR,"PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, sR, NA, NA, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}
}
for(vR in 1:3){
for(pc in proportionConflicting){
if(vR == 1){
# 1, 10
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
rate <- rgamma(1, shape = 1, scale = 10)
traits <- fastBM(tree, sig2 = rate)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD), paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "VarRatesShape1Scale10PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, NA, 1, 10, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}else if (vR == 2){
# 1, 1
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
rate <- rgamma(1, shape = 1, scale = 1)
traits <- fastBM(tree, sig2 = rate)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD), paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "VarRatesShape1Scale1PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, NA, 1, 1, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}else{
# 10, 1
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
rate <- rgamma(1, shape = 10, scale = 1)
traits <- fastBM(tree, sig2 = rate)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD),  paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "VarRatesShape10Scale10PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, NA, 10, 1, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}
}
}
}
return(list("phylo" = write.tree(tree), "resMat" = resMat))
}
resList <- pbapply::pblapply(1:length(phyloList), FUN = function(i){
return(simulationFunction(phyloList[[i]], i))
})
warnings()
tree = phyloList[[1]]
treeIdx = 1
resMat <- data.frame(matrix(data = NA, nrow = 0, ncol = 8))
colnames(resMat) <- c("RF", "SPR", "SPRe", "numCharacters", "setRate", "variableRateShape", "variableRateScale", "propConflicting")
for(nC in numCharacters){
for(sR in setRate){
for(pc in proportionConflicting){
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
traits <- fastBM(tree, sig2 = sR)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD), paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "SetRate", sR,"PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, sR, NA, NA, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}
}
for(vR in 1:3){
for(pc in proportionConflicting){
if(vR == 1){
# 1, 10
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
rate <- rgamma(1, shape = 1, scale = 10)
traits <- fastBM(tree, sig2 = rate)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD), paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "VarRatesShape1Scale10PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, NA, 1, 10, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}else if (vR == 2){
# 1, 1
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
rate <- rgamma(1, shape = 1, scale = 1)
traits <- fastBM(tree, sig2 = rate)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD), paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "VarRatesShape1Scale1PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, NA, 1, 1, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}else{
# 10, 1
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
rate <- rgamma(1, shape = 10, scale = 1)
traits <- fastBM(tree, sig2 = rate)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD),  paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "VarRatesShape10Scale10PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, NA, 10, 1, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}
}
}
}
datasetD
warnings()
as.data.table(datasetD)
data.table::as.data.table(datasetD)
View(datasetD)
View(data.table::as.data.table(datasetD))
d <- data.table::as.data.table(datasetD)
pcDistMat
for(nC in numCharacters){
for(sR in setRate){
for(pc in proportionConflicting){
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
traits <- fastBM(tree, sig2 = sR)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD), paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "SetRate", sR,"PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, sR, NA, NA, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}
}
for(vR in 1:3){
for(pc in proportionConflicting){
if(vR == 1){
# 1, 10
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
rate <- rgamma(1, shape = 1, scale = 10)
traits <- fastBM(tree, sig2 = rate)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD), paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "VarRatesShape1Scale10PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, NA, 1, 10, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}else if (vR == 2){
# 1, 1
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
rate <- rgamma(1, shape = 1, scale = 1)
traits <- fastBM(tree, sig2 = rate)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD), paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "VarRatesShape1Scale1PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, NA, 1, 1, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}else{
# 10, 1
for(d in numDatasets){
datasetD <- matrix(data = NA, nrow = Ntip(tree), ncol = nC)
rownames(datasetD) = tree$tip.label
for(t in 1:nC){
rate <- rgamma(1, shape = 10, scale = 1)
traits <- fastBM(tree, sig2 = rate)
datasetD[,t] <- traits
}
whichConflicting <- sample(1:nC, size = round(pc * nC), replace = FALSE)
for(t in whichConflicting){
newVec <- datasetD[,t]
tax <- sample(nrow(datasetD), 2, replace = F)
tax1Val <- newVec[tax[1]]
tax2Val <- newVec[tax[2]]
datasetD[tax[1],t] <- tax2Val
datasetD[tax[2],t] <- tax1Val
}
data.table::fwrite((datasetD),  paste("/Users/levir/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/SimRes/fastBMSimRes/fastBMTree", treeIdx, "NumChar", nC, "VarRatesShape10Scale10PropConflicting",pc,"Dataset",d,  ".csv", sep = ""), row.names = TRUE, verbose = FALSE)
pca <- prcomp(datasetD)
plotdf <- data.frame(tax = rownames(datasetD), pc1 = pca$x[,1], pc2 = pca$x[,2])
pcDistMat<- dist(plotdf)
njTree <- nj(pcDistMat)
unrootedTree <- unroot(tree)
unrootedNJTree <- unroot(njTree)
resVec <- c(dist.topo(unrootedNJTree, unrootedTree), rSPRFunc(unrootedNJTree, unrootedTree), sprMast(unrootedNJTree, unrootedTree), nC, NA, 10, 1, pc)
names(resVec) <- NULL
resMat[nrow(resMat) + 1, ] <- resVec
}
}
}
}
}
