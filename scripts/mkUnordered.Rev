## data read in
morpho <- readDiscreteCharacterData("/Users/levi/Documents/GitHub/PCAPhylogenetics/data/mongle_2023_rb.nex")

output <- "/Users/levi/Documents/GitHub/PCAPhylogenetics/results/Mongle_et_al_2023_RB/"

## helpers
num_taxa <- morpho.size()
num_branches <- 2 * num_taxa - 2
taxa <- morpho.names()

moves = VectorMoves()

#tree
br_len_lambda ~ dnExp(0.2)
moves.append(mvScale(br_len_lambda, weight=2))

phylogeny ~ dnUniformTopologyBranchLength(taxa, branchLengthDistribution=dnExponential(br_len_lambda))
moves.append(mvNNI(phylogeny, weight=num_branches/2.0))
moves.append(mvSPR(phylogeny, weight=num_branches/10.0))
moves.append(mvBranchLengthScale(phylogeny, weight=num_branches))
tree_length := phylogeny.treeLength()

#mk model
alpha_morpho ~ dnUniform( 0, 1E6 )
rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )
moves.append(mvScale(alpha_morpho, lambda=1, weight=2.0))

n_max_states <- morpho.maxStates()
idx = 1
morpho_bystate[1] <- morpho
for (i in 2:n_max_states) {
    morpho_bystate[i] <- morpho                                # make local tmp copy of data
    morpho_bystate[i].setNumStatesPartition(i)                 # only keep character blocks with state space equal to size i
    nc = morpho_bystate[i].nchar()                             # get number of characters per character size with i-sized states

    if (nc > 0) {                                              # for non-empty character blocks
        q[idx] <- fnJC(i)                                      # make i-by-i rate matrix
        m_morph[idx] ~ dnPhyloCTMC( tree=phylogeny,
                                    Q=q[idx],
                                    nSites=nc,
                                    siteRates=rates_morpho,
                                    type="Standard")           # create model of evolution for the character block

        m_morph[idx].clamp(morpho_bystate[i])                  # attach the data

        idx = idx + 1                                          # increment counter
        idx
    }
}


########
# MCMC #
########

# initialize the model object #
mymodel = model(phylogeny)

monitors = VectorMonitors()

# Create a vector of monitors #
# 1. for the full model #
monitors.append( mnModel(filename=output + "/hominin.log", printgen=10) )

# 2. the tree #
monitors.append( mnFile(filename=output + "/hominin.trees", printgen=10, phylogeny) )

# 3. and a few select parameters to be printed to the screen #
monitors.append( mnScreen(printgen=10) )

mymcmc = mcmcmc(mymodel, monitors, moves, nchains = 4)
mymcmc.run(generations=100000000)

#summarizing data

trace = readTreeTrace(output + "/hominin.trees")

# Summarize tree trace and save MCC tree to file
mccTree(trace, positiveBranchLengths = TRUE, file=output + "/hominin.mcc.tre")
consensusTree(trace, positiveBranchLengths = TRUE, file=output + "/hominin.majRule.tre" )

# Quit RevBayes #
q()
